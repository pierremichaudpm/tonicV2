# Fix pour les Liens, Texte Gras et Polices

## PROBL√àMES IDENTIFI√âS
1. **Liens ne fonctionnent pas tous** - D√©tection incompl√®te
2. **Texte gras n'appara√Æt pas** - Formatage Word pas bien captur√©
3. **Polices plus grandes n'apparaissent pas** - Styles pas appliqu√©s correctement

## SOLUTIONS AM√âLIOR√âES

### 1. REMPLACER la fonction `convertUrlsToLinks()` par cette version plus robuste:

```javascript
function convertUrlsToLinks(text) {
    if (!text) return text;
    
    // Skip if already contains links (but allow partial processing)
    let result = text;
    
    // 1. Email addresses (plus robuste)
    result = result.replace(
        /(?<!["'>])\b([A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,6})\b(?!["'<])/g,
        '<a href="mailto:$1" style="text-decoration: underline; color: #1d4ed8; font-weight: normal;">$1</a>'
    );
    
    // 2. URLs avec protocole (am√©lior√©)
    result = result.replace(
        /(?<!["'>])(https?:\/\/[A-Za-z0-9\-._~:/?#[\]@!$&'()*+,;=%]+)(?!["'<])/g,
        '<a href="$1" target="_blank" rel="noopener" style="text-decoration: underline; color: #1d4ed8; font-weight: normal;">$1</a>'
    );
    
    // 3. Domaines www (plus pr√©cis)
    result = result.replace(
        /(?<!["'>])\b(www\.[A-Za-z0-9\-._~]+\.[A-Za-z]{2,6}(?:\/[A-Za-z0-9\-._~:/?#[\]@!$&'()*+,;=%]*)?)\b(?!["'<])/g,
        '<a href="https://$1" target="_blank" rel="noopener" style="text-decoration: underline; color: #1d4ed8; font-weight: normal;">$1</a>'
    );
    
    // 4. Domaines simples (plus s√©lectif pour √©viter faux positifs)
    result = result.replace(
        /(?<![@\/."'>])\b([A-Za-z0-9\-]+\.(?:com|org|net|edu|gov|ca|fr|co\.uk|info|biz))\b(?![@\/."'<])/g,
        function(match, domain) {
            // √âviter les faux positifs
            if (result.includes(`@${domain}`) || result.includes(`//${domain}`) || 
                result.includes(`www.${domain}`) || result.includes(`>${domain}<`)) {
                return match;
            }
            return `<a href="https://${domain}" target="_blank" rel="noopener" style="text-decoration: underline; color: #1d4ed8; font-weight: normal;">${domain}</a>`;
        }
    );
    
    // 5. Patterns sp√©ciaux Word (liens cach√©s)
    result = result.replace(
        /\b(DOSSIER DE PRESSE|FORMULAIRE D['''¬¥]ACCR√âDITATION|PRESS KIT|ACCREDITATION FORM)\s*>>>?\s*/gi,
        '<a href="#" target="_blank" style="text-decoration: underline; color: #1d4ed8; font-weight: bold; background: #fff3cd; padding: 2px 4px; border-radius: 3px;">$1 ‚û§</a> <em style="color: #666; font-size: 0.9em;">(Remplacez # par l\'URL)</em>'
    );
    
    return result;
}
```

### 2. AM√âLIORER la fonction `processWordHTMLSimple()` pour mieux capturer le formatage:

```javascript
function processWordHTMLSimple(html) {
    if (!html || html.trim().length === 0) return '';
    
    console.log('üîç Processing Word HTML - Enhanced method');
    
    // Create temporary container
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;
    
    // Remove unwanted elements but keep content
    const unwanted = tempDiv.querySelectorAll('meta, style, script, xml, o\\:*, w\\:*');
    unwanted.forEach(el => {
        // Keep text content before removing
        const textContent = el.textContent || '';
        if (textContent.trim()) {
            el.replaceWith(document.createTextNode(textContent));
        } else {
            el.remove();
        }
    });
    
    let result = '';
    let currentParagraph = '';
    
    // More thorough processing
    function processNode(node, inheritedFormatting = {}) {
        if (node.nodeType === Node.TEXT_NODE) {
            const text = node.textContent.trim();
            if (text) {
                let formattedText = text;
                
                // Apply inherited formatting
                if (inheritedFormatting.bold) {
                    formattedText = `<strong>${formattedText}</strong>`;
                }
                if (inheritedFormatting.italic) {
                    formattedText = `<em>${formattedText}</em>`;
                }
                if (inheritedFormatting.large) {
                    formattedText = `<span style="font-size: 1.3em; font-weight: bold; display: inline-block; margin: 8px 0;">${formattedText}</span>`;
                }
                if (inheritedFormatting.link) {
                    formattedText = `<a href="${inheritedFormatting.link}" style="text-decoration: underline; color: #1d4ed8;" target="_blank">${formattedText}</a>`;
                }
                
                return formattedText;
            }
            return '';
        } else if (node.nodeType === Node.ELEMENT_NODE) {
            const tagName = node.tagName ? node.tagName.toLowerCase() : '';
            const style = node.style || {};
            const computedStyle = window.getComputedStyle ? window.getComputedStyle(node) : {};
            
            // Determine formatting
            const formatting = { ...inheritedFormatting };
            
            // Bold detection (multiple ways)
            if (tagName === 'strong' || tagName === 'b' || 
                style.fontWeight === 'bold' || style.fontWeight === '700' || style.fontWeight === 'bolder' ||
                computedStyle.fontWeight === 'bold' || computedStyle.fontWeight === '700' ||
                parseInt(style.fontWeight) >= 700 || parseInt(computedStyle.fontWeight) >= 700) {
                formatting.bold = true;
            }
            
            // Italic detection
            if (tagName === 'em' || tagName === 'i' || 
                style.fontStyle === 'italic' || computedStyle.fontStyle === 'italic') {
                formatting.italic = true;
            }
            
            // Large font detection (multiple ways)
            const fontSize = style.fontSize || computedStyle.fontSize || '';
            if (tagName.match(/^h[1-6]$/) || 
                fontSize.includes('large') || fontSize.includes('x-large') ||
                (fontSize.includes('pt') && parseInt(fontSize) > 12) ||
                (fontSize.includes('px') && parseInt(fontSize) > 16) ||
                tagName === 'title' || 
                (style.fontSize && parseFloat(style.fontSize) > 1.1)) {
                formatting.large = true;
            }
            
            // Link detection
            if (tagName === 'a' && node.href) {
                formatting.link = node.href;
            }
            
            // Process children
            let childContent = '';
            for (let child of node.childNodes) {
                childContent += processNode(child, formatting);
            }
            
            // Handle paragraph breaks
            if (tagName === 'p' || tagName === 'div' || tagName === 'h1' || tagName === 'h2' || 
                tagName === 'h3' || tagName === 'h4' || tagName === 'h5' || tagName === 'h6') {
                if (childContent.trim()) {
                    return `\n<p>${childContent.trim()}</p>\n`;
                }
            } else if (tagName === 'br') {
                return '\n';
            }
            
            return childContent;
        }
        return '';
    }
    
    // Process all content
    result = processNode(tempDiv);
    
    // Clean up and convert links
    result = result.replace(/\n\s*\n+/g, '\n').trim();
    result = convertUrlsToLinks(result);
    
    // Ensure we have proper paragraphs
    if (result && !result.includes('<p>')) {
        const lines = result.split('\n').filter(line => line.trim());
        result = lines.map(line => `<p>${line.trim()}</p>`).join('\n');
    }
    
    return result;
}
```

### 3. AM√âLIORER aussi la fonction `processPlainTextSimple()`:

```javascript
function processPlainTextSimple(text) {
    if (!text || text.trim().length === 0) return '';
    
    console.log('üìù Processing plain text - Enhanced method');
    
    // Clean up Word special characters
    let cleanText = text
        .replace(/[\u2018\u2019]/g, "'") // Smart quotes
        .replace(/[\u201C\u201D]/g, '"') // Smart quotes
        .replace(/\u2013/g, '-') // En dash
        .replace(/\u2014/g, '‚Äî') // Em dash (keep long dash)
        .replace(/\u2026/g, '...') // Ellipsis
        .replace(/\u00A0/g, ' ') // Non-breaking space
        .replace(/\r\n/g, '\n') // Windows line endings
        .replace(/\r/g, '\n'); // Mac line endings
    
    // Detect and preserve bold text markers from plain text
    cleanText = cleanText.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    cleanText = cleanText.replace(/\*([^*]+)\*/g, '<em>$1</em>');
    
    // Detect probable titles (lines that are shorter and followed by longer content)
    const lines = cleanText.split('\n');
    const processedLines = [];
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        // Detect titles: short lines (< 80 chars) that are followed by longer content
        // or lines that are all caps or start with caps and are short
        const nextLine = lines[i + 1] ? lines[i + 1].trim() : '';
        const isLikelyTitle = (
            (line.length < 80 && nextLine.length > line.length) ||
            (line === line.toUpperCase() && line.length > 5 && line.length < 60) ||
            (line.match(/^[A-Z√Ä√â√à√ä√ã√è√é√î√ñ√ô√ö√õ√ú≈∏√á][A-Z√Ä√â√à√ä√ã√è√é√î√ñ√ô√ö√õ√ú≈∏√á\s]{5,50}$/) && !line.includes('.'))
        );
        
        if (isLikelyTitle) {
            processedLines.push(`<p><strong style="font-size: 1.3em; display: block; margin: 10px 0; color: #333;">${line}</strong></p>`);
        } else {
            processedLines.push(line);
        }
    }
    
    // Join back and split into paragraphs
    const rejoinedText = processedLines.join('\n');
    const paragraphs = rejoinedText
        .split(/\n\s*\n+/)
        .map(para => para.trim().replace(/\n+/g, ' ').replace(/\s+/g, ' '))
        .filter(para => para.length > 3);
    
    // If no clear paragraphs found, make reasonable splits
    if (paragraphs.length <= 1 && cleanText.length > 200) {
        // Split on sentence endings followed by capital letters
        const sentences = cleanText.split(/(?<=[.!?])\s+(?=[A-Z√Ä√â√à√ä√ã√è√é√î√ñ√ô√ö√õ√ú≈∏√á])/);
        if (sentences.length > 1) {
            return sentences.map(sentence => {
                const trimmed = sentence.trim();
                if (trimmed.includes('<strong style="font-size')) {
                    return trimmed; // Already formatted as title
                }
                return `<p>${convertUrlsToLinks(trimmed)}</p>`;
            }).join('\n');
        }
    }
    
    // Convert each paragraph and add links
    const result = paragraphs
        .map(para => {
            if (para.includes('<strong style="font-size')) {
                return para; // Already formatted as title
            }
            return `<p>${convertUrlsToLinks(para)}</p>`;
        })
        .join('\n');
    
    return result || `<p>${convertUrlsToLinks(cleanText)}</p>`;
}
```

### 4. AJOUTER une fonction de test pour v√©rifier le formatage:

```javascript
// FONCTION DE TEST - ajouter temporairement pour debug
function testFormattingProcessing() {
    console.log('üß™ Testing formatting processing...');
    
    // Test avec diff√©rents types de contenu
    const testCases = [
        {
            name: 'Email simple',
            text: 'Contact: test@groupetonic.com pour plus d\'info'
        },
        {
            name: 'URL avec protocole',
            text: 'Visitez https://www.groupetonic.com pour en savoir plus'
        },
        {
            name: 'Domaine www',
            text: 'Allez sur www.groupetonic.com'
        },
        {
            name: 'Domaine simple',
            text: 'Notre site: groupetonic.com'
        },
        {
            name: 'Texte avec formatting',
            text: 'TITRE IMPORTANT\n\nCeci est un paragraphe normal avec **texte gras** et un lien vers test@example.com.\n\nAutre paragraphe avec www.example.com.'
        }
    ];
    
    testCases.forEach(testCase => {
        console.log(`\n--- Test: ${testCase.name} ---`);
        console.log('Input:', testCase.text);
        
        const processed = processPlainTextSimple(testCase.text);
        console.log('Processed:', processed);
        
        // Test preview display
        const previewDiv = document.createElement('div');
        previewDiv.innerHTML = processed;
        console.log('Preview text:', previewDiv.textContent);
        console.log('Preview HTML:', previewDiv.innerHTML);
    });
}

// Appeler dans la console: testFormattingProcessing()
```

## INSTRUCTIONS POUR TESTER

1. **Remplacez** les 3 fonctions (`convertUrlsToLinks`, `processWordHTMLSimple`, `processPlainTextSimple`)
2. **Ajoutez** la fonction de test temporairement
3. **Testez** en copiant diff√©rents types de contenu:
   - Texte avec emails et URLs
   - Document Word avec texte en gras
   - Document Word avec titres plus grands
4. **V√©rifiez** la console avec `testFormattingProcessing()` pour voir le processing
5. **V√©rifiez** l'aper√ßu dans le CMS et le r√©sultat final sur le site web

## AM√âLIORATIONS CL√âS

‚úÖ **D√©tection de liens renforc√©e**: Regex plus robustes, √©vite les faux positifs  
‚úÖ **Capture du gras am√©lior√©e**: Plusieurs m√©thodes de d√©tection du formatage Word  
‚úÖ **D√©tection des titres**: Reconna√Æt les polices plus grandes et les convertit correctement  
‚úÖ **Styles inline**: Applique les styles directement pour √©viter les conflits CSS  
‚úÖ **Meilleur debugging**: Fonction de test pour identifier les probl√®mes  

Ces am√©liorations devraient r√©soudre les probl√®mes de liens, texte gras et polices plus grandes!