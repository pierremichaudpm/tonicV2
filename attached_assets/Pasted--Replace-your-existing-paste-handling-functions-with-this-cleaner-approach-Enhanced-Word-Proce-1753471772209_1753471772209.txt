// Replace your existing paste handling functions with this cleaner approach

// Enhanced Word Processor Class
class WordProcessor {
    constructor() {
        // Map of Word styles to HTML tags
        this.styleToTag = {
            'bold': 'strong',
            'italic': 'em',
            'underline': 'u'
        };
        
        // Font size mapping (Word pt to CSS classes)
        this.fontSizeMap = {
            '8': 'text-xs',
            '9': 'text-sm',
            '10': 'text-sm',
            '11': 'text-base',
            '12': 'text-base',
            '14': 'text-lg',
            '16': 'text-lg',
            '18': 'text-xl',
            '20': 'text-xl',
            '24': 'text-2xl',
            '28': 'text-3xl',
            '32': 'text-4xl'
        };
    }

    // Main processing function
    processContent(clipboardData, fieldId) {
        let processedHTML = '';
        
        // Try HTML first
        if (clipboardData.types.includes('text/html')) {
            const htmlData = clipboardData.getData('text/html');
            if (htmlData && htmlData.trim()) {
                processedHTML = this.processWordHTML(htmlData);
            }
        }
        
        // Fallback to plain text
        if (!processedHTML && clipboardData.types.includes('text/plain')) {
            const textData = clipboardData.getData('text/plain');
            if (textData && textData.trim()) {
                processedHTML = this.processPlainText(textData);
            }
        }
        
        return processedHTML;
    }

    processWordHTML(html) {
        // Create temporary container
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = html;
        
        // Remove Word cruft
        this.cleanWordElements(tempDiv);
        
        // Process content
        const blocks = [];
        this.processNode(tempDiv, blocks);
        
        // Join blocks and clean up
        return blocks.join('\n').trim();
    }

    cleanWordElements(container) {
        // Remove Word-specific elements
        const wordElements = container.querySelectorAll('meta, link, style, xml, o\\:p, script, colgroup, col');
        wordElements.forEach(el => el.remove());
        
        // Remove comments
        const walker = document.createTreeWalker(
            container,
            NodeFilter.SHOW_COMMENT,
            null,
            false
        );
        const comments = [];
        while (walker.nextNode()) {
            comments.push(walker.currentNode);
        }
        comments.forEach(comment => comment.remove());
        
        // Clean attributes
        const allElements = container.querySelectorAll('*');
        allElements.forEach(el => {
            // Keep only essential attributes
            const keepAttrs = ['href', 'src', 'colspan', 'rowspan'];
            Array.from(el.attributes).forEach(attr => {
                if (!keepAttrs.includes(attr.name) && !attr.name.startsWith('data-')) {
                    el.removeAttribute(attr.name);
                }
            });
        });
    }

    processNode(node, blocks, inlineFormatting = []) {
        // Handle text nodes
        if (node.nodeType === Node.TEXT_NODE) {
            const text = node.textContent.replace(/\s+/g, ' ').trim();
            if (text) {
                return this.applyInlineFormatting(text, inlineFormatting);
            }
            return '';
        }
        
        // Handle element nodes
        if (node.nodeType === Node.ELEMENT_NODE) {
            const tag = node.tagName.toLowerCase();
            const style = window.getComputedStyle(node);
            
            // Handle block elements
            if (this.isBlockElement(tag)) {
                const blockContent = this.processBlockElement(node, tag, style);
                if (blockContent) {
                    blocks.push(blockContent);
                }
                return '';
            }
            
            // Handle inline elements
            return this.processInlineElement(node, tag, style, inlineFormatting);
        }
        
        return '';
    }

    isBlockElement(tag) {
        const blockTags = ['p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'li', 'table', 'tr', 'td', 'th', 'blockquote'];
        return blockTags.includes(tag);
    }

    processBlockElement(node, tag, style) {
        // Handle headings
        if (tag.match(/^h[1-6]$/)) {
            const content = this.extractInlineContent(node);
            return content ? `<${tag}>${content}</${tag}>` : '';
        }
        
        // Handle lists
        if (tag === 'ul' || tag === 'ol') {
            const items = Array.from(node.querySelectorAll(':scope > li'))
                .map(li => {
                    const content = this.extractInlineContent(li);
                    return content ? `<li>${content}</li>` : '';
                })
                .filter(item => item);
            
            return items.length ? `<${tag}>\n${items.join('\n')}\n</${tag}>` : '';
        }
        
        // Handle tables
        if (tag === 'table') {
            return this.processTable(node);
        }
        
        // Handle paragraphs and divs
        if (tag === 'p' || tag === 'div') {
            const content = this.extractInlineContent(node);
            
            if (!content) return '';
            
            // Check for heading-like styling
            const fontSize = parseFloat(style.fontSize);
            const isBold = style.fontWeight === 'bold' || parseInt(style.fontWeight) >= 700;
            
            if (fontSize > 16 && isBold) {
                return `<h3>${content}</h3>`;
            }
            
            return `<p>${content}</p>`;
        }
        
        // Default block handling
        const content = this.extractInlineContent(node);
        return content ? `<p>${content}</p>` : '';
    }

    processTable(table) {
        const rows = Array.from(table.querySelectorAll('tr'));
        if (!rows.length) return '';
        
        let html = '<table class="table table-bordered">\n';
        
        rows.forEach((row, index) => {
            html += '<tr>';
            const cells = Array.from(row.querySelectorAll('td, th'));
            cells.forEach(cell => {
                const tag = cell.tagName.toLowerCase();
                const content = this.extractInlineContent(cell);
                const colspan = cell.getAttribute('colspan') || 1;
                const rowspan = cell.getAttribute('rowspan') || 1;
                
                let attrs = '';
                if (colspan > 1) attrs += ` colspan="${colspan}"`;
                if (rowspan > 1) attrs += ` rowspan="${rowspan}"`;
                
                html += `<${tag}${attrs}>${content}</${tag}>`;
            });
            html += '</tr>\n';
        });
        
        html += '</table>';
        return html;
    }

    processInlineElement(node, tag, style, parentFormatting) {
        const formatting = [...parentFormatting];
        
        // Check for formatting
        if (tag === 'strong' || tag === 'b' || (style.fontWeight === 'bold' || parseInt(style.fontWeight) >= 700)) {
            formatting.push('strong');
        }
        if (tag === 'em' || tag === 'i' || style.fontStyle === 'italic') {
            formatting.push('em');
        }
        if (tag === 'u' || style.textDecoration.includes('underline')) {
            formatting.push('u');
        }
        
        // Handle links
        if (tag === 'a' && node.href) {
            const content = this.extractInlineContent(node, formatting);
            return `<a href="${node.href}" target="_blank">${content}</a>`;
        }
        
        // Process children with updated formatting
        return this.extractInlineContent(node, formatting);
    }

    extractInlineContent(node, formatting = []) {
        let content = '';
        
        for (let child of node.childNodes) {
            if (child.nodeType === Node.TEXT_NODE) {
                const text = child.textContent.replace(/\s+/g, ' ');
                if (text.trim()) {
                    content += this.applyInlineFormatting(text, formatting);
                }
            } else if (child.nodeType === Node.ELEMENT_NODE) {
                content += this.processInlineElement(child, child.tagName.toLowerCase(), window.getComputedStyle(child), formatting);
            }
        }
        
        return content.trim();
    }

    applyInlineFormatting(text, formatting) {
        if (!text || !formatting.length) return text;
        
        // Remove duplicates and sort for consistent nesting
        const uniqueFormats = [...new Set(formatting)];
        
        // Apply formatting in order
        let result = text;
        uniqueFormats.forEach(format => {
            result = `<${format}>${result}</${format}>`;
        });
        
        return result;
    }

    processPlainText(text) {
        // Clean special characters
        text = text
            .replace(/[\u2018\u2019]/g, "'")
            .replace(/[\u201C\u201D]/g, '"')
            .replace(/\u2013/g, '-')
            .replace(/\u2014/g, 'â€”')
            .replace(/\u2026/g, '...')
            .replace(/\u00A0/g, ' ')
            .trim();
        
        // Convert URLs to links
        text = this.convertUrlsToLinks(text);
        
        // Split into paragraphs
        const paragraphs = text.split(/\n\s*\n+/)
            .map(p => p.trim())
            .filter(p => p)
            .map(p => `<p>${p.replace(/\n/g, '<br>')}</p>`);
        
        return paragraphs.join('\n');
    }

    convertUrlsToLinks(text) {
        // Email addresses
        text = text.replace(
            /([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/g,
            '<a href="mailto:$1">$1</a>'
        );
        
        // URLs with protocol
        text = text.replace(
            /(https?:\/\/[^\s<>"']+)(?![^<]*>|[^<>]*<\/a>)/g,
            '<a href="$1" target="_blank">$1</a>'
        );
        
        // URLs starting with www
        text = text.replace(
            /\b(www\.[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}[^\s<>"']*)(?![^<]*>|[^<>]*<\/a>)/g,
            '<a href="https://$1" target="_blank">$1</a>'
        );
        
        return text;
    }
}

// Initialize the processor
const wordProcessor = new WordProcessor();

// Replace your existing handlePaste function
function handlePaste(event, fieldId) {
    event.preventDefault();
    
    const clipboardData = event.clipboardData || window.clipboardData;
    if (!clipboardData) return;
    
    debugLog('ðŸ”¥ Enhanced paste handler triggered', fieldId);
    
    // Process the content
    const processedHTML = wordProcessor.processContent(clipboardData, fieldId);
    
    if (processedHTML) {
        // Get the textarea
        const textarea = document.getElementById(fieldId);
        if (!textarea) return;
        
        // Store the processed content
        textarea.setAttribute('data-processed-content', processedHTML);
        
        // Show in textarea (you might want to show plain text version)
        textarea.value = processedHTML;
        
        // Show preview
        showContentPreview(fieldId, processedHTML);
        
        debugLog('âœ… Content processed successfully', `Length: ${processedHTML.length}`);
    }
}

// Enhanced preview function
function showContentPreview(fieldId, content) {
    const previewDiv = document.getElementById(fieldId + 'Preview');
    const previewText = document.getElementById(fieldId + 'PreviewText');
    
    if (previewDiv && previewText && content) {
        previewText.innerHTML = content;
        previewDiv.style.display = 'block';
        
        // Add CSS for better preview styling
        if (!document.getElementById('preview-styles')) {
            const style = document.createElement('style');
            style.id = 'preview-styles';
            style.innerHTML = `
                .cms-content-preview { line-height: 1.6; }
                .cms-content-preview p { margin: 0.5em 0; }
                .cms-content-preview h1 { font-size: 2em; font-weight: bold; margin: 0.67em 0; }
                .cms-content-preview h2 { font-size: 1.5em; font-weight: bold; margin: 0.83em 0; }
                .cms-content-preview h3 { font-size: 1.17em; font-weight: bold; margin: 1em 0; }
                .cms-content-preview ul, .cms-content-preview ol { margin: 0.5em 0; padding-left: 2em; }
                .cms-content-preview li { margin: 0.25em 0; }
                .cms-content-preview table { border-collapse: collapse; margin: 1em 0; }
                .cms-content-preview td, .cms-content-preview th { border: 1px solid #ddd; padding: 8px; }
                .cms-content-preview th { background-color: #f4f4f4; font-weight: bold; }
                .cms-content-preview blockquote { border-left: 4px solid #ddd; margin: 1em 0; padding-left: 1em; color: #666; }
                .cms-content-preview .text-xs { font-size: 0.75em; }
                .cms-content-preview .text-sm { font-size: 0.875em; }
                .cms-content-preview .text-lg { font-size: 1.125em; }
                .cms-content-preview .text-xl { font-size: 1.25em; }
                .cms-content-preview .text-2xl { font-size: 1.5em; }
                .cms-content-preview .text-3xl { font-size: 1.875em; }
                .cms-content-preview .text-4xl { font-size: 2.25em; }
            `;
            document.head.appendChild(style);
        }
    }
}

// Add this to your document ready or initialization
document.addEventListener('DOMContentLoaded', function() {
    // Your existing initialization code...
    
    // Ensure paste handlers are attached
    const descField = document.getElementById('description');
    const contentField = document.getElementById('content');
    
    if (descField) {
        descField.removeEventListener('paste', (e) => handlePaste(e, 'description'));
        descField.addEventListener('paste', (e) => handlePaste(e, 'description'));
    }
    
    if (contentField) {
        contentField.removeEventListener('paste', (e) => handlePaste(e, 'content'));
        contentField.addEventListener('paste', (e) => handlePaste(e, 'content'));
    }
});