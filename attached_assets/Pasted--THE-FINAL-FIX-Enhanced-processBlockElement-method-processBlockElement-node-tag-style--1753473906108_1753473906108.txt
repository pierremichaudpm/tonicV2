// THE FINAL FIX - Enhanced processBlockElement method

processBlockElement(node, tag, style) {
    if (tag.match(/^h[1-6]$/)) {
        const content = this.extractInlineContent(node);
        return content ? `<${tag}>${content}</${tag}>` : '';
    }
    
    if (tag === 'ul' || tag === 'ol') {
        const items = Array.from(node.querySelectorAll(':scope > li'))
            .map(li => {
                const content = this.extractInlineContent(li);
                return content ? `<li>${content}</li>` : '';
            })
            .filter(item => item);
        
        return items.length ? `<${tag}>\n${items.join('\n')}\n</${tag}>` : '';
    }
    
    if (tag === 'p' || tag === 'div') {
        const content = this.extractInlineContent(node);
        
        if (!content) return '';
        
        // ENHANCED PARAGRAPH SPLITTING LOGIC
        // Check if this is a mega-paragraph (very long content in single <p>)
        if (content.length > 500 && !content.includes('</p>')) {
            console.log('üî• Splitting mega-paragraph intelligently');
            
            // Split on sentence endings followed by capital letters (French pattern)
            let paragraphs = [];
            let currentParagraph = '';
            
            // Split into sentences first
            const sentences = content.split(/(?<=[.!?¬ª])\s+/);
            
            sentences.forEach((sentence, index) => {
                currentParagraph += sentence + ' ';
                
                // Create new paragraph based on multiple criteria:
                const nextSentence = sentences[index + 1] || '';
                const shouldBreak = 
                    // 1. Next sentence starts with specific French patterns
                    /^(L'√©lite|L'√©nergie|Les |Le |La |Plus |Un |Une |Apr√®s |Suite |Pour |D√©clarations|CONTACT|√Ä propos)/.test(nextSentence) ||
                    // 2. Current sentence ends with closing quote and next starts with opening quote
                    (/¬ª$/.test(sentence.trim()) && /^¬´/.test(nextSentence)) ||
                    // 3. Next sentence starts with a date pattern
                    /^(Montr√©al|MONTR√âAL|Du |Le \d)/.test(nextSentence) ||
                    // 4. Every 2-3 sentences for very long content
                    (currentParagraph.length > 400 && /[.!?¬ª]$/.test(sentence.trim()));
                
                if (shouldBreak && currentParagraph.trim()) {
                    paragraphs.push(`<p>${currentParagraph.trim()}</p>`);
                    currentParagraph = '';
                }
            });
            
            // Add any remaining content
            if (currentParagraph.trim()) {
                paragraphs.push(`<p>${currentParagraph.trim()}</p>`);
            }
            
            return paragraphs.join('\n');
        }
        
        // For shorter content or already well-structured content
        return `<p>${content}</p>`;
    }
    
    const content = this.extractInlineContent(node);
    return content ? `<p>${content}</p>` : '';
}

// ALSO UPDATE THE PLAIN TEXT PROCESSOR for better paragraph detection
processPlainText(text) {
    text = text
        .replace(/[\u2018\u2019]/g, "'")
        .replace(/[\u201C\u201D]/g, '"')
        .replace(/[\u2013]/g, '‚Äì')  // En dash
        .replace(/[\u2014]/g, '‚Äî')  // Em dash
        .replace(/\u2026/g, '...')
        .replace(/\u00A0/g, ' ')
        .replace(/[\u00AB]/g, '¬´ ') // Opening guillemet with space
        .replace(/[\u00BB]/g, ' ¬ª') // Closing guillemet with space
        .trim();
    
    text = this.convertUrlsToLinks(text);
    
    // ENHANCED PARAGRAPH DETECTION
    let paragraphs = [];
    
    // First try to split on double line breaks
    let chunks = text.split(/\n\s*\n+/);
    
    // If we only get one chunk, try to split intelligently
    if (chunks.length === 1 && text.length > 500) {
        const longText = chunks[0];
        let currentPara = '';
        
        // Split on sentences
        const sentences = longText.split(/(?<=[.!?¬ª])\s+/);
        
        sentences.forEach((sentence, index) => {
            currentPara += sentence + ' ';
            const nextSentence = sentences[index + 1] || '';
            
            // Smart break detection
            const shouldBreak = 
                /^(Montr√©al|MONTR√âAL|L'√©lite|L'√©nergie|Les |Le |La |Plus |Un |Une |Apr√®s |Suite |Pour |D√©clarations|¬´ )/.test(nextSentence) ||
                (/¬ª\s*$/.test(sentence) && /^¬´/.test(nextSentence)) ||
                (currentPara.length > 400 && /[.!?¬ª]$/.test(sentence.trim()));
            
            if (shouldBreak && currentPara.trim()) {
                paragraphs.push(currentPara.trim());
                currentPara = '';
            }
        });
        
        if (currentPara.trim()) {
            paragraphs.push(currentPara.trim());
        }
    } else {
        // Use the natural breaks
        paragraphs = chunks.map(p => p.trim()).filter(p => p);
    }
    
    // Convert to HTML paragraphs
    return paragraphs.map(p => `<p>${p}</p>`).join('\n');
}

// CRITICAL: Update handlePaste to show plain text in textarea but store HTML
function handlePaste(event, fieldId) {
    event.preventDefault();
    
    const clipboardData = event.clipboardData || window.clipboardData;
    if (!clipboardData) return;
    
    console.log('üî• Enhanced paste handler triggered', fieldId);
    
    const processedHTML = wordProcessor.processContent(clipboardData, fieldId);
    
    if (processedHTML) {
        const textarea = document.getElementById(fieldId);
        if (!textarea) return;
        
        // Store the processed HTML
        textarea.setAttribute('data-processed-content', processedHTML);
        
        // IMPORTANT: Show plain text in textarea, not HTML!
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = processedHTML;
        textarea.value = tempDiv.textContent || tempDiv.innerText || '';
        
        // Show formatted preview
        showContentPreview(fieldId, processedHTML);
        
        console.log('‚úÖ Content processed successfully');
        console.log('üìÑ HTML stored:', processedHTML.substring(0, 200) + '...');
    }
}

// Make sure preview shows correctly
function showContentPreview(fieldId, content) {
    const previewDiv = document.getElementById(fieldId + 'Preview');
    const previewText = document.getElementById(fieldId + 'PreviewText');
    
    if (previewDiv && previewText && content) {
        previewText.innerHTML = content;
        previewDiv.classList.remove('hidden');
        previewDiv.style.display = 'block';
        
        console.log('üëÅÔ∏è Preview updated with', content.split('<p>').length - 1, 'paragraphs');
    }
}

// When editing, show both plain text AND preview
async function editItem(id) {
    try {
        const endpoint = currentType === 'jobs' ? '/api/cms/jobs' : '/api/cms/news';
        const response = await fetch(endpoint, {
            headers: { 'X-Admin-Password': 'admin123' }
        });

        if (response.ok) {
            const data = await response.json();
            const items = data[currentType] || data.jobs || data.news || [];
            const item = items.find(i => i.id == id);
            
            if (item) {
                currentEditId = id;
                document.getElementById('formTitle').textContent = currentType === 'jobs' ? 'Modifier l\'emploi' : 'Modifier le communiqu√©';
                document.getElementById('title').value = item.title;
                document.getElementById('date').value = item.date;
                document.getElementById('category').value = item.category;
                document.getElementById('summary').value = item.summary;
                
                // Show plain text in textarea
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = item.content;
                document.getElementById('content').value = tempDiv.textContent || tempDiv.innerText || '';
                
                // Store the HTML
                document.getElementById('content').setAttribute('data-processed-content', item.content);
                
                // Show the preview immediately
                showContentPreview('content', item.content);
                
                document.getElementById('formModal').classList.remove('hidden');
            }
        }
    } catch (error) {
        console.error('Erreur:', error);
    }
}

// Test function you can run in console
window.testParagraphSplit = function() {
    const testText = `Montr√©al, le 17 juin 2025 ‚Äì Le plus haut niveau du volleyball de plage est de retour √† Montr√©al! Du 13 au 17 ao√ªt 2025, le Beach Pro Tour ‚Äì Elite transformera le l√©gendaire circuit Gilles-Villeneuve en une ar√®ne spectaculaire o√π s'affronteront les meilleures √©quipes f√©minines et masculines au monde. Apr√®s une √©dition 2023 marqu√©e par les victoires retentissantes des Canadiennes Melissa Humana-Paredes et Brandie Wilkerson, ainsi que des Norv√©giens Anders Mol et Christian S√∏rum, le tournoi s'annonce encore plus √©lectrisant cette ann√©e au Montr√©al Beach Pro Tour. Suite √† une spectaculaire m√©daille d'argent aux Jeux de Paris 2024, Humana-Paredes et Wilkerson reviennent √† Montr√©al en v√©ritables h√©ro√Ønes nationales du volleyball pour participer √† la seule √©tape canadienne du circuit. L'√©lite mondiale. L'√©nergie de Montr√©al. Les 32 meilleures √©quipes au monde s'affronteront pendant 5 jours pour gravir le classement international et Montr√©al est la seule occasion de le faire en territoire nord-am√©ricain sur le calendrier mondial 2025. Les Montr√©alaises et Montr√©alais ont donc une chance unique d'assister √† ces duels. Plus qu'un simple tournoi, Montr√©al Beach Pro Tour promet une ambiance survolt√©e : DJ sur place, zone gourmande, animations et exp√©riences immersives. Un √©v√©nement festif qui marie sport de haut niveau, culture urbaine et plaisir estival. Les billets sont en vente d√®s maintenant! Rendez-vous sur mtlbeachprotour.com pour acc√©der aux meilleurs si√®ges pour vivre l'√©v√©nement au coeur de l'action.`;
    
    const processor = new WordProcessor();
    const result = processor.processPlainText(testText);
    
    console.log('Original length:', testText.length);
    console.log('Paragraphs created:', result.split('<p>').length - 1);
    console.log('Result:', result);
    
    // Show in preview
    document.getElementById('content').value = testText;
    document.getElementById('content').setAttribute('data-processed-content', result);
    showContentPreview('content', result);
    
    return result;
};